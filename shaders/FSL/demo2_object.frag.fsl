#include "demo2_resources.h.fsl"

STRUCT(VSOutput)
{
    DATA(float4, Position, SV_POSITION);
    DATA(float4, WorldPos, POSITION0);
    DATA(float4, Color,    COLOR);
    DATA(float4, Normal,   NORMAL);
    DATA(float4, ShadowMapPos, POSITION1);
};

float3 doDirectionalLight(
    VSOutput In,
    float4 cameraPosition,
    float4 lightDirection, float4 lightColor,
    float lightIntensity, float ambientFactor, float smoothness)
{
    float3 litColor = lightColor.rgb * In.Color.rgb;

    float diffuseFactor = dot(normalize(In.Normal.xyz), -normalize(lightDirection.xyz)) * lightIntensity;
    if(diffuseFactor < 0) diffuseFactor = 0;

    float3 viewDir = normalize(cameraPosition.xyz - In.WorldPos.xyz);
    float3 reflectDir = reflect(lightDirection.xyz, In.Normal.xyz);

    float specularFactor = pow(max(dot(viewDir, reflectDir), 0.0), 32) * smoothness * diffuseFactor;

    return litColor * (diffuseFactor + ambientFactor + specularFactor);
}

float4 PS_MAIN( VSOutput In )
{
    INIT_MAIN;
    float4 Out = {0.0, 0.0, 0.0, 0.0};

    int i = 0;
    for(i = 0; i < LIGHT_COUNT; i++)
    {
        Out.rgb += doDirectionalLight(
            In, Get(cameraPosition),
            Get(lightDirection[i]), Get(lightColor[i]),
            Get(lightIntensity[i]), Get(lightAmbient[i]),
            Get(color).a);
    }

    float2 shadowMapCoord = (In.ShadowMapPos.xy + 1.0 )/2.0;
    // shadowMapCoord.x = 1.0 - shadowMapCoord.x;

    float depth = SampleLvlTex2D(Get(shadowMap), Get(bilinearSampler), shadowMapCoord, 0).x;	// TODO point sampler
    if (depth <= In.ShadowMapPos.z) {
        Out.rgb = Out.rgb / 2.0;
    }

    Out.a = 1.0;

    RETURN(Out);
}