#include "demo2_resources.h.fsl"

STRUCT(VSOutput)
{
    DATA(float4, Position, SV_POSITION);
    DATA(float4, WorldPos, POSITION0);
    DATA(float4, Color, COLOR);
    DATA(float4, Normal, NORMAL);
    DATA(float4, ShadowMapPos, POSITION1);
    DATA(float2, ShadowMapCoord, TEXCOORD0);
    DATA(float4, ShadowMapCoordOffset1, TEXCOORD1);
    DATA(float4, ShadowMapCoordOffset2, TEXCOORD2);
    DATA(float4, ShadowMapCoordOffset3, TEXCOORD3);
    DATA(float4, ShadowMapCoordOffset4, TEXCOORD4);
};

float3 doDirectionalLight(VSOutput In, float4 cameraPosition, float4 lightDirection, float4 lightColor,
                          float lightIntensity, float ambientFactor, float smoothness)
{
    float3 litColor = lightColor.rgb * In.Color.rgb;

    float diffuseFactor = dot(normalize(In.Normal.xyz), -normalize(lightDirection.xyz)) * lightIntensity;
    if (diffuseFactor < 0)
        diffuseFactor = 0;

    float3 viewDir = normalize(cameraPosition.xyz - In.WorldPos.xyz);
    float3 reflectDir = reflect(lightDirection.xyz, In.Normal.xyz);

    float specularFactor = pow(max(dot(viewDir, reflectDir), 0.0), 32) * smoothness * diffuseFactor;

    return litColor * (diffuseFactor + ambientFactor + specularFactor);
}

float calculateDepth(VSOutput In)
{
    float3x3 values;
    values[0][0] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoordOffset3.xy).x * 1 / 16;
    values[0][1] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoordOffset2.xy).x * 1 / 8;
    values[0][2] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoordOffset4.xy).x * 1 / 16;
    values[1][0] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoordOffset1.xy).x * 1 / 8;
    values[1][1] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoord).x * 1 / 4;
    values[1][2] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoordOffset1.zw).x * 1 / 8;
    values[2][0] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoordOffset4.zw).x * 1 / 16;
    values[2][1] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoordOffset2.zw).x * 1 / 8;
    values[2][2] = SampleTex2D(Get(shadowMap), Get(pointSampler), In.ShadowMapCoordOffset3.zw).x * 1 / 16;

    return (values[0][0] + values[0][1] + values[0][2]) + (values[1][0] + values[1][1] + values[1][2]) +
        (values[2][0] + values[2][1] + values[2][2]);
}

float4 PS_MAIN(VSOutput In)
{
    INIT_MAIN;
    float4 Out = {0.0, 0.0, 0.0, 0.0};

    int i = 0;
    float3 ambientColor = {0, 0, 0};

    for (i = 0; i < LIGHT_COUNT; i++)
    {
        float3 baseColor = Get(lightColor[i]).rgb * In.Color.rgb;
        ambientColor += baseColor * Get(lightAmbient[i]);

        Out.rgb += doDirectionalLight(In, Get(cameraPosition), Get(lightDirection[i]), Get(lightColor[i]),
                                      Get(lightIntensity[i]), Get(lightAmbient[i]), Get(color).a);
    }

    float2 shadowMapCoord = In.ShadowMapCoord;

    if (In.ShadowMapCoord.x >= 0 && In.ShadowMapCoord.y >= 0 && In.ShadowMapCoord.x <= 1.0 &&
        In.ShadowMapCoord.y <= 1.0)
    {
        float litdepth = calculateDepth(In);
        bool isDirectlyLit = dot(normalize(In.Normal.xyz), -normalize(Get(lightDirection[0]).xyz)) > 0;

        if (isDirectlyLit && litdepth != 0 && (litdepth - In.ShadowMapPos.z) > 0.01)
        {
            Out.rgb = ambientColor;
        }
    }

    RETURN(Out);
}