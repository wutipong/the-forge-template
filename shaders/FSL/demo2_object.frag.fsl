#include "demo2_resources.h.fsl"

STRUCT(VSOutput)
{
    DATA(float4, Position, SV_POSITION);
    DATA(float4, WorldPos, POSITION0);
    DATA(float4, Color, COLOR);
    DATA(float4, Normal, NORMAL);
    DATA(float4, ShadowMapPos, POSITION1);
    DATA(float2, ShadowMapCoord, TEXCOORD0);
};

float3 doDirectionalLight(VSOutput In, float4 cameraPosition, float4 lightDirection, float4 lightColor,
                          float lightIntensity, float ambientFactor, float smoothness)
{
    float3 litColor = lightColor.rgb * In.Color.rgb;

    float diffuseFactor = dot(normalize(In.Normal.xyz), -normalize(lightDirection.xyz)) * lightIntensity;
    if (diffuseFactor < 0)
        diffuseFactor = 0;

    float3 viewDir = normalize(cameraPosition.xyz - In.WorldPos.xyz);
    float3 reflectDir = reflect(lightDirection.xyz, In.Normal.xyz);

    float specularFactor = pow(max(dot(viewDir, reflectDir), 0.0), 32) * smoothness * diffuseFactor;

    return litColor * (diffuseFactor + ambientFactor + specularFactor);
}

// source: https://www.shadertoy.com/view/4sfGzS
float hash(float3 p)
{
	p = frac(p*0.3183099 + .1);
	p *= 17.0;
	return frac(p.x*p.y*p.z*(p.x + p.y + p.z));
}

float noise(in(float3) x)
{
	float3 p = floor(x);
	float3 f = frac(x);
	f = f * f*(3.0 - 2.0*f);

	return lerp(lerp(lerp(hash(p + float3(0, 0, 0)),
		hash(p + float3(1, 0, 0)), f.x),
		lerp(hash(p + float3(0, 1, 0)),
		hash(p + float3(1, 1, 0)), f.x), f.y),
		lerp(lerp(hash(p + float3(0, 0, 1)),
		hash(p + float3(1, 0, 1)), f.x),
		lerp(hash(p + float3(0, 1, 1)),
		hash(p + float3(1, 1, 1)), f.x), f.y), f.z);
}


float4 PS_MAIN(VSOutput In)
{
    INIT_MAIN;
    float4 Out = {0.0, 0.0, 0.0, 0.0};

    int i = 0;
    float3 ambientColor = {0, 0, 0};

    for (i = 0; i < LIGHT_COUNT; i++)
    {
        float3 baseColor = Get(lightColor[i]).rgb * In.Color.rgb;
        ambientColor += baseColor * Get(lightAmbient[i]);

        Out.rgb += doDirectionalLight(In, Get(cameraPosition), Get(lightDirection[i]), Get(lightColor[i]),
                                      Get(lightIntensity[i]), Get(lightAmbient[i]), Get(color).a);
    }

    float2 shadowMapCoord = In.ShadowMapCoord;

    if (In.ShadowMapCoord.x >= 0 && In.ShadowMapCoord.y >= 0 && In.ShadowMapCoord.x <= 1.0 &&
        In.ShadowMapCoord.y <= 1.0)
    {
        float2 samplingLoc = In.ShadowMapCoord + noise(In.Position.xyz * 10) * float2(3/1024.0, 3/1024.0);

        float litdepth = SampleTex2D(Get(shadowMap), Get(pointSampler), samplingLoc).x;
        bool isDirectionalHit = dot(normalize(In.Normal.xyz), -normalize(Get(lightDirection[0]).xyz)) > 0;

        if (isDirectionalHit && (litdepth - max(In.ShadowMapPos.z, 0.0)) > 0.01)
        {
            Out.rgb = ambientColor;
        }
    }

    RETURN(Out);
}